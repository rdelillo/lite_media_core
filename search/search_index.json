{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"lite_media_core <p>   A streamlined Python framework for developers to validate, control, and inspect media workflows.   Built for ingest pipelines, quality control automation, final delivery checks and image sequence validation. </p> Quick Start <p>Install and start validating media instantly with no configuration overhead.</p>        \ud83d\ude80 Get Started      \ud83d\uddc2\ufe0f Discover media assets <p>Scan folders for video, audio, or image files recursively.</p> See example \ud83c\udfac Video codec and frame rate <p>Validate codec and frame rate against specifications.</p> See example \ud83e\uddd0 Missing or corrupted frames <p>Identify frame gaps or corruptions in sequences.</p> See example \ud83d\uddbc\ufe0f Detect inconsistent resolutions <p>Quickly spot resolution anomalies across sequences.</p> See example \ud83d\udd0e Access detailed media metadata <p>Retrieve complete metadata as a Python dictionary.</p> See example \u23f1\ufe0fEmbedded video timecodes <p>Extract and verify embedded video timecodes.</p> See example And much more... <ul> <li>Detect anamorphic images</li> <li>Legal vs full color range</li> <li>Inspect audio sample rates</li> <li>Media factory from path</li> </ul> \ud83e\uddea Experimental <ul> <li>Load media from URLs</li> </ul> Need help? <p>Contributions are always welcome!</p>      \ud83d\udcac Open an Issue    Credits <p>This project builds on the shoulders of amazing open-source tools:</p> <ul> <li>MediaInfo \u2014 Cross-platform media metadata engine</li> <li>pymediainfo \u2014 Python wrapper around MediaInfo</li> <li>fileseq \u2014 Frame-based sequence management</li> <li>timecode \u2014 Timecode parsing and manipulation</li> </ul> About <p>lite_media_core was built by a developer, for developers.</p> <p>It aims to make media validation, automation, and ingestion pipelines faster, simpler, and more reliable.</p> <p>It draws inspiration from workflows I first encountered at MPC (Technicolor), then helped refine at RodeoFX and other studios, evolving with my own needs over time.</p> <p>       \u2014 @rdelillo </p>"},{"location":"quickstart/","title":"Get Started","text":""},{"location":"quickstart/#install","title":"\ud83d\udce6 Install","text":"<p>First, install the package:</p> <pre><code>pip install lite_media_core\n</code></pre>"},{"location":"quickstart/#introduction-using-a-video","title":"\ud83c\udfac Introduction using a Video","text":""},{"location":"quickstart/#1-download-sample-video","title":"1. Download sample video","text":"<p>Grab a ready-to-use video for testing</p> <p></p> <pre><code>import requests\n\nurl = (\n    \"https://github.com/rdelillo/lite_media_core/raw/refs\"\n    \"/heads/main/docs/assets/quickstart.mp4\"\n)\noutput_path = \"video.mp4\"\n\nresponse = requests.get(url, stream=True)\nresponse.raise_for_status()\n\nwith open(output_path, \"wb\") as f:\n    for chunk in response.iter_content(chunk_size=8192):\n        if chunk:\n            f.write(chunk)\n\nprint(f\"Downloaded {output_path}\")\n</code></pre>"},{"location":"quickstart/#2-inspect-video-metadata","title":"2. Inspect video metadata","text":"<p>Load the media using lite_media_core:</p> <pre><code>from lite_media_core import Movie\n\nmedia = Movie(\"video.mp4\")\n\nassert media.exists\n\nprint(f\"Path: {media.path}\")\nprint(f\"Resolution: {media.resolution}\")\nprint(f\"Codec: {media.codec}\")\nprint(f\"Duration: {media.duration} ({media.duration.seconds} seconds)\")\nprint(f\"Frame rate: {media.frame_rate}\")\nprint(f\"Total frames: {int(media.duration)}\")\n\n# Full metadata access\nprint(media.metadata)\n</code></pre>"},{"location":"quickstart/#next-steps","title":"\ud83e\udde9 Next steps","text":"<ul> <li>Load an image</li> <li>Load an image sequence</li> <li>More info about Movie media</li> <li>Automatically detect media files and sequences from folders</li> </ul>"},{"location":"api/audio/","title":"Audio","text":""},{"location":"api/audio/#audio","title":"\ud83c\udfa7 Audio","text":""},{"location":"api/audio/#1-create-an-audio-object","title":"1. Create an <code>Audio</code> object","text":"<pre><code>from lite_media_core import Audio\n\naudio = Audio(\"path/to/audio.mp3\")\n\nif audio.exists:\n    print(\"Duration (seconds):\", audio.duration)\n    print(\"Bitrate (bps):\", audio.bitrate)\n    print(\"Sampling rate (Hz):\", audio.sampling_rate)\n</code></pre>"},{"location":"api/future/","title":"Experimental","text":"<pre><code>TODO document embedded features.\n</code></pre>"},{"location":"api/movie/","title":"Movie","text":""},{"location":"api/movie/#movie","title":"\ud83c\udfac Movie","text":""},{"location":"api/movie/#1-create-a-movie-object","title":"1. Create a <code>Movie</code> object","text":"<pre><code>from lite_media_core import media\n\nmovie = media.Movie(\"path/to/video.mov\")\n\nprint(\"Codec:\", movie.codec)\nprint(\"Frame rate:\", movie.frame_rate)\nprint(\"Duration:\", movie.duration)\nprint(\"Frame range:\", movie.frame_range)\nprint(\"Full metadata:\", movie.metadata)\n</code></pre>"},{"location":"api/movie/#2-handling-unsupported-paths","title":"2. Handling unsupported paths","text":"<p>If the provided path is not a recognized video format, a UnsupportedMimeType exception is raised.</p> <pre><code>from lite_media_core import Movie, UnsupportedMimeType\n\ntry:\n    movie = Movie(\"path/to/file.txt\")\n\nexcept UnsupportedMimeType as error:\n    print(f\"Not a valid video: {error}\")\n</code></pre>"},{"location":"api/movie/#3-offline-movie","title":"3. Offline <code>Movie</code>","text":"<p>You can instantiate a Movie even if the file doesn't exist. Accessing media properties will raise an exception if the file is missing.</p> <pre><code>from lite_media_core import Movie, MediaException\n\nmovie = Movie(\"path/to/video.mov\")\n\ntry:\n    print(\"Codec:\", movie.codec)\nexcept MediaException:\n    if not movie.exists:\n        print(f\"Movie {movie.path} is offline.\")\n    else:\n        raise\n</code></pre>"},{"location":"api/movie/#common-use-cases","title":"\ud83c\udfaf Common Use-cases","text":""},{"location":"api/movie/#1-checking-framerate","title":"1. Checking <code>FrameRate</code>","text":"<pre><code>from lite_media_core import Movie, FrameRate\n\nmovie = Movie(\"path/to/video.mov\")\nprint(f\"value: {float(movie.frame_rate)} fps\")\n\nif movie.frame_rate.is_standard:\n    print(f\"Standard frame rate {movie.frame_rate.name}\")\n\nelse:\n    print(f\"Non-standard frame rate\")\n    print(f\"Standard rates are {FrameRate.get_industry_standards()}\")\n</code></pre>"},{"location":"api/movie/#2-inspect-embedded-timecode","title":"2. Inspect embedded Timecode","text":"<p>What is an embedded timecode ?</p> <pre><code>from lite_media_core import Movie\n\nmovie = Movie(\"path/to/video.mov\")\n\nif movie.timecode:\n    print(f\"Embedded timecode: {movie.timecode}\")\n    print(f\"As frames: {int(movie.timecode)}\")\n\nelse:\n    print(\"No embedded timecode found.\")\n</code></pre>"},{"location":"api/movie/#3-checking-color-range-full-vs-legal","title":"3. Checking Color Range (Full vs Legal)","text":"<p>What are full and legal color ranges ?</p> <pre><code>from lite_media_core import Movie\n\nmovie = Movie(\"path/to/video.mov\")\ncolour_range = movie.metadata.get(\"Video\", {}).get(\"colour_range\")\n\nif colour_range == \"Limited\":\n    print(\"Movie is legal/video color range.\")\n\nelif colour_range:\n    print(\"Movie is full color range.\")\n\nelse:\n    print(\"Undefined colour range.\")\n</code></pre> <p>Warning</p> <p>TODO Metadata fields like colour_range may not always be available depending on the media file.</p>"},{"location":"api/sequence/","title":"Image(s)","text":""},{"location":"api/sequence/#image","title":"\ud83d\uddbc\ufe0f Image","text":""},{"location":"api/sequence/#1-create-an-image-object","title":"1. Create an <code>Image</code> object","text":"<pre><code>from lite_media_core import Image\n\nimg = Image(\"path/to/image.png\")\n\nif img.exists:  # Check if online?\n    width, height = img.resolution\n    print(\"Resolution:\", img.resolution)\n    print(\"Frame Range:\", img.frame_range)\n    print(\"Metadata:\", img.metadata)\n</code></pre> <p>Lazy Loading: metadata is loaded only when accessing a property for the first time.</p> <p>Frame Extraction: if the filename includes a frame number (e.g. <code>image.0125.png</code>), the <code>frame_range</code> is automatically set.</p>"},{"location":"api/sequence/#2-check-image-channels","title":"2. Check image channels","text":"<pre><code>TODO\n</code></pre>"},{"location":"api/sequence/#3-image-mime-types","title":"3. Image MIME types","text":"<p>Checking the media type (instead of the file extension) provides a more reliable detection \u2014 it handles casing (JPG vs jpg) and common extension variants (jpg vs jpeg).</p> <pre><code>from lite_media_core import Image\n\njpg_img = _image_media.ImageMedia(\"path/to/image.JPG\")\njpeg_img = _image_media.ImageMedia(\"path/to/image.jpeg\")\n\nassert jpg_img.type == jpeg_img.type  # \"image\"\nassert jpg_img.sub_type == jpeg_img.sub_type  # \"jpeg\"\n</code></pre>"},{"location":"api/sequence/#4-anamorphic-resolution","title":"4. Anamorphic resolution","text":"<pre><code>from lite_media_core import Image\n\nimg = Image(\"path/to/anamorphic_image.exr\")\n\nif img.resolution.pixel_aspect_ratio != 1.0:\n    print(f\"Image {img} is anamorphic.\")\n</code></pre>"},{"location":"api/sequence/#imagesequence","title":"\ud83c\udf9e\ufe0f ImageSequence","text":"<p><code>ImageSequence</code> groups a series of numbered images (e.g., <code>img.1001.exr</code>, <code>img.1002.exr</code>, etc.) into a single logical media object. It supports validation, frame iteration, resolution consistency checking, and missing frame detection.</p>"},{"location":"api/sequence/#1-create-an-imagesequence-object","title":"1. Create an <code>ImageSequence</code> object","text":"<p>You can create an <code>ImageSequence</code> from:</p> <ul> <li>A formatted sequence path</li> <li>A list of image paths</li> <li>Scanning a folder with <code>medios</code></li> </ul> <pre><code>from lite_media_core import ImageSequence\n\n# From a path\nseq = ImageSequence(\"path/to/sequence.1001-1010#.exr\")\n\n# From a list of images\nseq_from_list = ImageSequence.from_list([\n    \"path/to/frame.0000.exr\",\n    \"path/to/frame.0001.exr\",\n    \"path/to/frame.0002.exr\",\n])\n</code></pre> <p>You can create an image sequence from path variations. <pre><code>from lite_media_core import ImageSequence\n\nseq1 = ImageSequence(\"/path/to/sequence.1001-1010#.exr\")\nseq2 = ImageSequence(\"/path/to/a/sequence.%04d.ext [1-2, 9-10]\")\nseq3 = ImageSequence(\"/path/to/a/sequence.@@@.ext 1-5\")\nseq4 = ImageSequence(\"/path/to/a/sequence_1-5.ext\")\n</code></pre></p>"},{"location":"api/sequence/#2-sequence-properties","title":"2. Sequence properties","text":"<p>When accessing properties like resolution, metadata, or mime_type, ImageSequence automatically delegates the call to the first available frame. This ensures quick access without scanning the entire sequence.</p> <pre><code>from lite_media_core import ImageSequence\n\nseq = ImageSequence(\"path/to/sequence.1001-1010#.exr\")\n\n# These properties are delegated to the first frame internally\nprint(\"Resolution:\", seq.resolution)\nprint(\"Metadata:\", seq.metadata)\nprint(f\"MIME type: {seq.type}/{seq.sub_type}.\")\n</code></pre>"},{"location":"api/sequence/#3-format-sequence-path","title":"3. Format sequence path","text":"<pre><code># Example output: path/to/sequence.####.exr 1001-1010\nprint(seq.path)\n\nprint(seq.head)   # \"sequence.\"\nprint(seq.tail)   # \".exr\"\nprint(seq.padding)  # 4\n</code></pre> <p>also using some helpers: <pre><code>from lite_media_core import sequence\nfrom lite_media_core import ImageSequence\n\nseq = ImageSequence(\"path/to/sequence.1001-1010#.exr\")\nseq.format(sequence.PredefinedFormat.FFMPEG)  # path/to/sequence.%04d.exr\n</code></pre></p>"},{"location":"api/sequence/#4-iterate-over-the-sequence","title":"4. Iterate over the sequence","text":"<pre><code>for frame in seq:\n    print(frame.path)  # frame in an Image object\n</code></pre> <p>Access a specific frame directly: <pre><code>from lite_media_core import ImageSequence\n\nseq = ImageSequence(\"path/to/sequence.1001-1010#.exr\")\n\nprint(seq.get_frame_path(1005))  # path/to/sequence.1005.exr\n</code></pre></p>"},{"location":"api/sequence/#5-detect-missing-or-corrupted-frames","title":"5. Detect missing or corrupted frames","text":"<p>Loop over the missing frames: <pre><code>from lite_media_core import ImageSequence\n\nseq = ImageSequence(\"path/to/sequence.1001-1010#.exr\")\n\nfor frame in seq.missing:\n    print(f\"Missing frame: {frame.path}\")\n</code></pre></p> <p>Validate a sequence with the built-in validate(): <pre><code>from lite_media_core import ImageSequence\n\ntry:\n    seq = ImageSequence(\"path/to/inconsistent_sequence.1001-1005#.exr\")\n    seq.validate()\n\nexcept ValueError as e:\n    print(f\"Inconsistent sequence detected: {e}\")\n</code></pre></p>"},{"location":"api/sequence/#6-check-inconsistent-resolution","title":"6. Check inconsistent resolution","text":"<p>You can use the built-in <code>validate()</code> method (see above).</p> <p>You can also validate frame resolutions asynchronously for better performance on large sequences:</p> <pre><code>import asyncio\nfrom lite_media_core import media\n\n\nasync def _check_resolution(frame, expected_resolution):\n    \"\"\"Async check for a single frame.\"\"\"\n    return frame.resolution == expected_resolution\n\n\nasync def validate_sequence_resolution(seq: media.ImageSequence):\n    \"\"\"Async validate that all frames match the same resolution.\"\"\"\n\n    # Use the first available frame as the reference\n    expected_resolution = seq.resolution\n\n    tasks = [\n        _check_resolution(frame, expected_resolution)\n        for frame in seq\n    ]\n\n    results = await asyncio.gather(*tasks)\n\n    # Return frames that mismatch.\n    return [frame for frame, is_valid in zip(seq, results) if not is_valid]\n\n\nasync def main():\n    seq = media.ImageSequence(\"path/to/sequence.1001-1020#.exr\")\n    mismatched_frames = await validate_sequence_resolution(seq)\n\n    if mismatched_frames:\n        print(f\"Frames with wrong resolution: {mismatched_frames}.\")\n    else:\n        print(\"All frames have consistent resolution.\")\n\n# Run\nasyncio.run(main())\n</code></pre>"},{"location":"api/utils/","title":"Utils","text":""},{"location":"api/utils/#movie-factory-using-media","title":"\ud83d\udcda Movie factory using <code>Media</code>","text":"<p>You can use the <code>Media.from_path</code> factory to create the relevant media object.</p> <pre><code>from lite_media_core import Media, Audio, Image, ImageSequence, Movie\nfrom lite_media_core import UnsupportedMimeType\n\n\ntry:\n    media_obj = Media.from_path(\"/path/to/some_media.ext\")\n\nexcept UnsupportedMimeType as error:\n    print(f\"Unrecognized media path: {error}.\")\n\nelse:\n    if isinstance(media_obj, Movie):\n        print(f\"{media_obj} is a movie.\")\n    elif isinstance(media_obj, ImageSequence):\n        print(f\"{media_obj} is an image sequence.\")\n    elif isinstance(media_obj, Image):\n        print(f\"{media_obj} is a single image.\")\n    elif isinstance(media_obj, Audio):\n        print(f\"{media_obj} is an audio.\")\n\n    print(media_obj.metadata)\n</code></pre>"},{"location":"api/utils/#discover-media-with-mediaos","title":"\ud83d\udcc2 Discover media with <code>mediaos</code>","text":"<p>Quickly browse folders and automatically detect media files and sequences.</p> Function Purpose <code>listdir()</code> List a folder (non-recursive) and detect media. <code>walk()</code> Recursively walk directories and detect media. <code>identify_from_files()</code> Identify media from a list of paths."},{"location":"api/utils/#listdir","title":"<code>listdir</code>","text":"<p>List all entries in a folder (non-recursive) and identify media objects.</p> <pre><code>from lite_media_core import mediaos, Media\n\nitems = mediaos.listdir(\"/path/to/folder\")\n\nfor item in items:\n    if isinstance(item, Media):\n        print(f\"Found media: {item.path}\")\n</code></pre> <p>Note</p> <p><code>listdir()</code> only lists files in the top-level folder. It does not search recursively.</p>"},{"location":"api/utils/#walk","title":"<code>walk</code>","text":"<p>Recursively walk through a directory tree and return media objects.</p> <pre><code>from lite_media_core import mediaos, Media\n\nfor root, dirs, files in mediaos.walk(\"/path/to/root\"):\n    for item in files:\n        if isinstance(item, Media):\n            print(f\"Found media: {item.path}\")\n</code></pre> <p>Tip</p> <p>Use <code>isinstance(item, media.Media)</code> to differentiate between media and regular files.</p>"},{"location":"api/utils/#identify_from_files","title":"<code>identify_from_files</code>","text":"<p>Identify media from a given list of file paths.</p> <pre><code>from lite_media_core import mediaos\n\nfiles = [\n    \"clip.mov\",\n    \"sequence.1001.exr\",\n    \"sequence.1002.exr\",\n]\n\nmedias = mediaos.identify_from_files(files)\n\nfor m in medias:\n    print(f\"Identified media: {m.path} (exists={m.exists})\")\n</code></pre> <p>Warning</p> <p>Files that are not recognized as valid media will be silently ignored.</p>"},{"location":"api/utils/#represent-non-media-sequence","title":"\ud83d\udcc4 Represent non-media sequence","text":"<pre><code>TODO\n</code></pre>"}]}